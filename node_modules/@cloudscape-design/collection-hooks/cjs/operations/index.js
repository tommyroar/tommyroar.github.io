"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.itemsAreEqual = exports.processSelectedItems = void 0;
exports.processItems = processItems;
const filter_js_1 = require("./filter.js");
const property_filter_js_1 = require("./property-filter.js");
const sort_js_1 = require("./sort.js");
const pagination_js_1 = require("./pagination.js");
const compose_filters_js_1 = require("./compose-filters.js");
const internal_1 = require("@cloudscape-design/component-toolkit/internal");
const items_tree_js_1 = require("./items-tree.js");
function processItems(allItems, state, { filtering, sorting, pagination, propertyFiltering, expandableRows, selection }) {
    var _a, _b, _c, _d;
    const filterPredicate = (0, compose_filters_js_1.composeFilters)((0, property_filter_js_1.createPropertyFilterPredicate)(propertyFiltering, state.propertyFilteringQuery), (0, filter_js_1.createFilterPredicate)(filtering, state.filteringText));
    const sortingComparator = (0, sort_js_1.createComparator)(sorting, state.sortingState);
    const { items, rootItemsCount, selectableItemsCount, getItemChildren, isItemExpandable, getItemsCount } = expandableRows
        ? (0, items_tree_js_1.computeTreeItems)(allItems, expandableRows, filterPredicate, sortingComparator)
        : (0, items_tree_js_1.computeFlatItems)(allItems, filterPredicate, sortingComparator);
    const filteredItemsCount = filterPredicate ? rootItemsCount : undefined;
    let getSelectedItemsCount = undefined;
    let selectedItems = undefined;
    if (selection && (expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.dataGrouping) && state.groupSelection && getItemChildren) {
        const trackBy = (_a = selection === null || selection === void 0 ? void 0 : selection.trackBy) !== null && _a !== void 0 ? _a : expandableRows === null || expandableRows === void 0 ? void 0 : expandableRows.getId;
        const selectionTreeProps = { getChildren: getItemChildren, trackBy };
        const selectionTree = new internal_1.SelectionTree(items, selectionTreeProps, state.groupSelection);
        selectedItems = selectionTree.getSelectedItems();
        getSelectedItemsCount = selectionTree.getSelectedItemsCount;
    }
    const expandableRowsResult = getItemChildren && {
        getItemChildren,
        isItemExpandable,
        getItemsCount,
        totalItemsCount: selectableItemsCount,
        getSelectedItemsCount,
        totalSelectedItemsCount: (_d = (_b = selectedItems === null || selectedItems === void 0 ? void 0 : selectedItems.length) !== null && _b !== void 0 ? _b : (_c = state.selectedItems) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0,
    };
    const pageProps = (0, pagination_js_1.createPageProps)(pagination, state.currentPageIndex, items);
    if (pageProps) {
        return {
            items: items.slice((pageProps.pageIndex - 1) * pageProps.pageSize, pageProps.pageIndex * pageProps.pageSize),
            allPageItems: items,
            totalItemsCount: rootItemsCount,
            filteredItemsCount,
            pagesCount: pageProps === null || pageProps === void 0 ? void 0 : pageProps.pagesCount,
            actualPageIndex: pageProps === null || pageProps === void 0 ? void 0 : pageProps.pageIndex,
            selectedItems,
            expandableRows: expandableRowsResult,
        };
    }
    return {
        items: items,
        allPageItems: items,
        totalItemsCount: rootItemsCount,
        filteredItemsCount,
        pagesCount: undefined,
        actualPageIndex: undefined,
        selectedItems,
        expandableRows: expandableRowsResult,
    };
}
const processSelectedItems = (items, selectedItems, trackBy) => {
    const selectedSet = new Set();
    selectedItems.forEach(item => selectedSet.add((0, internal_1.getTrackableValue)(trackBy, item)));
    return items.filter(item => selectedSet.has((0, internal_1.getTrackableValue)(trackBy, item)));
};
exports.processSelectedItems = processSelectedItems;
const itemsAreEqual = (items1, items2, trackBy) => {
    if (items1.length !== items2.length) {
        return false;
    }
    const set1 = new Set();
    items1.forEach(item => set1.add((0, internal_1.getTrackableValue)(trackBy, item)));
    return items2.every(item => set1.has((0, internal_1.getTrackableValue)(trackBy, item)));
};
exports.itemsAreEqual = itemsAreEqual;
