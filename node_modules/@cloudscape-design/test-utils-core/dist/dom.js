"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWrapper = exports.ComponentWrapper = exports.ElementWrapper = exports.AbstractWrapper = exports.usesDom = void 0;
const utils_1 = require("./utils");
const utils_dom_1 = require("./utils-dom");
// Used as decorator to mark dom-only methods in test-utils
const usesDom = () => { };
exports.usesDom = usesDom;
const defaultParams = {
    bubbles: true,
    cancelable: true,
};
class AbstractWrapper {
    constructor(element) {
        this.element = element;
    }
    getElement() {
        return this.element;
    }
    /**
     * Performs a click by triggering a mouse event.
     * Note that programmatic events ignore disabled attribute and will trigger listeners even if the element is disabled.
     */
    click(params) {
        this.fireEvent(new MouseEvent('click', Object.assign(Object.assign({}, defaultParams), params)));
    }
    keydown(args) {
        const params = typeof args === 'object' ? args : { keyCode: args };
        this.fireEvent(new KeyboardEvent('keydown', Object.assign(Object.assign({}, defaultParams), params)));
    }
    keyup(args) {
        const params = typeof args === 'object' ? args : { keyCode: args };
        this.fireEvent(new KeyboardEvent('keyup', Object.assign(Object.assign({}, defaultParams), params)));
    }
    keypress(args) {
        // React more or less requires charCode to be set on keypress events
        // https://github.com/facebook/react/blob/d95c4938df670a8f0a13267bd89173737bb185e4/packages/react-dom/src/events/plugins/SimpleEventPlugin.js#L67-L74
        const params = typeof args === 'object' ? args : { keyCode: args, charCode: args };
        this.fireEvent(new KeyboardEvent('keypress', Object.assign(Object.assign({}, defaultParams), params)));
    }
    fireEvent(event) {
        (0, utils_dom_1.act)(() => {
            this.element.dispatchEvent(event);
        });
    }
    focus() {
        if (this.element instanceof HTMLElement || this.element instanceof SVGElement) {
            const element = this.element;
            (0, utils_dom_1.act)(() => {
                element.focus();
            });
        }
        else {
            throw new Error('Focus method is not supported for this element type');
        }
    }
    blur() {
        if (this.element instanceof HTMLElement || this.element instanceof SVGElement) {
            const element = this.element;
            (0, utils_dom_1.act)(() => {
                element.blur();
            });
        }
        else {
            throw new Error('Blur method is not supported for this element type');
        }
    }
    find(selector) {
        return this.findAll(selector)[0] || null;
    }
    matches(selector) {
        return this.element.matches(selector) ? this : null;
    }
    findAll(selector) {
        let elements;
        if ((0, utils_1.isScopedSelector)(selector)) {
            const randomValue = Math.floor(Math.random() * 100000);
            const attributeName = `data-awsui-test-scope-${randomValue}`;
            const domSelector = (0, utils_1.substituteScope)(selector, `[${attributeName}]`);
            this.getElement().setAttribute(attributeName, '');
            elements = Array.prototype.slice.call(this.element.querySelectorAll(domSelector));
            this.getElement().removeAttribute(attributeName);
        }
        else {
            elements = Array.prototype.slice.call(this.element.querySelectorAll(selector));
        }
        return elements.map(element => new ElementWrapper(element));
    }
    findAny(...selectors) {
        return this.find(selectors.join(', '));
    }
    findByClassName(className) {
        return this.find(`.${className}`);
    }
    findAllByClassName(className) {
        return this.findAll(`.${className}`);
    }
    /**
     * Returns the component wrapper matching the specified selector.
     * If the specified selector doesn't match any element, it returns `null`.
     *
     * Note: This function returns the specified component's wrapper even if the specified selector points to a different component type.
     *
     * @param {string} selector CSS selector
     * @param {WrapperClass} ComponentClass Component's wrapper class
     * @returns `Wrapper | null`
     */
    findComponent(selector, ComponentClass) {
        const elementWrapper = this.find(selector);
        return elementWrapper ? new ComponentClass(elementWrapper.getElement()) : null;
    }
    /**
     * Returns the wrappers of all components that match the specified component type and the specified CSS selector.
     * If no CSS selector is specified, returns all of the components that match the specified component type.
     * If no matching component is found, returns an empty array.
     *
     * @param {ComponentWrapperClass} ComponentClass Component's wrapper class
     * @param {string} [selector] CSS selector
     * @returns `Array<Wrapper>`
     */
    findAllComponents(ComponentClass, selector) {
        let componentRootSelector = `.${ComponentClass.rootSelector}`;
        if ('legacyRootSelector' in ComponentClass && ComponentClass.legacyRootSelector) {
            componentRootSelector = `:is(.${ComponentClass.rootSelector}, .${ComponentClass.legacyRootSelector})`;
        }
        const componentCombinedSelector = selector
            ? (0, utils_1.appendSelector)(componentRootSelector, selector)
            : componentRootSelector;
        const elementWrappers = this.findAll(componentCombinedSelector);
        return elementWrappers.map(wrapper => new ComponentClass(wrapper.getElement()));
    }
}
exports.AbstractWrapper = AbstractWrapper;
class ElementWrapper extends AbstractWrapper {
}
exports.ElementWrapper = ElementWrapper;
class ComponentWrapper extends AbstractWrapper {
}
exports.ComponentWrapper = ComponentWrapper;
function createWrapper(root = document.body) {
    if (document && document.body && !document.body.contains(root)) {
        console.warn('[AwsUi] [test-utils] provided element is not part of the document body, interactions may work incorrectly');
    }
    return new ElementWrapper(root);
}
exports.createWrapper = createWrapper;
