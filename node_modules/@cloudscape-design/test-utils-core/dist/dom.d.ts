import { IElementWrapper } from './interfaces';
import { KeyCode } from './utils';
declare global {
    interface KeyboardEventInit {
        char?: string;
        keyCode?: number;
        charCode?: number;
    }
}
export declare const usesDom: MethodDecorator;
interface WrapperClass<Wrapper, ElementType> {
    new (element: ElementType): Wrapper;
}
interface ComponentWrapperClass<Wrapper, ElementType> extends WrapperClass<Wrapper, ElementType> {
    rootSelector: string;
    legacyRootSelector?: string;
}
export declare class AbstractWrapper<ElementType extends Element> implements IElementWrapper<ElementType, Array<ElementWrapper<ElementType>>> {
    protected element: ElementType;
    constructor(element: ElementType);
    getElement(): ElementType;
    /**
     * Performs a click by triggering a mouse event.
     * Note that programmatic events ignore disabled attribute and will trigger listeners even if the element is disabled.
     */
    click(params?: MouseEventInit): void;
    keydown(keyCode: KeyCode): void;
    keydown(keyboardEventProps: KeyboardEventInit): void;
    keyup(keyCode: KeyCode): void;
    keyup(keyboardEventProps: KeyboardEventInit): void;
    keypress(keyCode: KeyCode): void;
    keypress(keyboardEventProps: KeyboardEventInit): void;
    fireEvent(event: Event): void;
    focus(): void;
    blur(): void;
    find<NewElementType extends Element = HTMLElement>(selector: string): ElementWrapper<NewElementType> | null;
    matches(selector: string): this | null;
    findAll<NewElementType extends Element = HTMLElement>(selector: string): ElementWrapper<NewElementType>[];
    findAny<NewElementType extends Element = HTMLElement>(...selectors: Array<string>): ElementWrapper<NewElementType> | null;
    findByClassName<NewElementType extends HTMLElement = HTMLElement>(className: string): ElementWrapper<NewElementType> | null;
    findAllByClassName<NewElementType extends HTMLElement = HTMLElement>(className: string): ElementWrapper<NewElementType>[];
    /**
     * Returns the component wrapper matching the specified selector.
     * If the specified selector doesn't match any element, it returns `null`.
     *
     * Note: This function returns the specified component's wrapper even if the specified selector points to a different component type.
     *
     * @param {string} selector CSS selector
     * @param {WrapperClass} ComponentClass Component's wrapper class
     * @returns `Wrapper | null`
     */
    findComponent<Wrapper extends ComponentWrapper, ElementType extends HTMLElement>(selector: string, ComponentClass: WrapperClass<Wrapper, ElementType>): Wrapper | null;
    /**
     * Returns the wrappers of all components that match the specified component type and the specified CSS selector.
     * If no CSS selector is specified, returns all of the components that match the specified component type.
     * If no matching component is found, returns an empty array.
     *
     * @param {ComponentWrapperClass} ComponentClass Component's wrapper class
     * @param {string} [selector] CSS selector
     * @returns `Array<Wrapper>`
     */
    findAllComponents<Wrapper extends ComponentWrapper, ElementType extends HTMLElement>(ComponentClass: ComponentWrapperClass<Wrapper, ElementType>, selector?: string): Array<Wrapper>;
}
export declare class ElementWrapper<ElementType extends Element = HTMLElement> extends AbstractWrapper<ElementType> {
}
export declare class ComponentWrapper<ElementType extends Element = HTMLElement> extends AbstractWrapper<ElementType> {
}
export declare function createWrapper(root?: Element): ElementWrapper<Element>;
export {};
