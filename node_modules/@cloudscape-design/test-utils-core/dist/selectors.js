"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWrapper = exports.MultiElementWrapper = exports.ComponentWrapper = exports.ElementWrapper = exports.AbstractWrapper = void 0;
const utils_1 = require("./utils");
const getRootSelector = (selector, root) => {
    const rootSelector = (0, utils_1.isScopedSelector)(selector) ? (0, utils_1.substituteScope)(selector, root) : `${root} ${selector}`;
    return (0, utils_1.getUnscopedClassName)(rootSelector);
};
class AbstractWrapper {
    constructor(root) {
        this.root = root;
    }
    getElement() {
        return this.root;
    }
    matches(selector) {
        return new ElementWrapper((0, utils_1.appendSelector)(this.root, (0, utils_1.getUnscopedClassName)(selector)));
    }
    find(selector) {
        return new ElementWrapper(getRootSelector(selector, this.root));
    }
    findAll(selector) {
        return new MultiElementWrapper(getRootSelector(selector, this.root), selector => new ElementWrapper(selector));
    }
    findAny(...selectors) {
        return this.find(`:is(${selectors.map(selector => (0, utils_1.getUnscopedClassName)(selector)).join(', ')})`);
    }
    findByClassName(className) {
        return this.find(`.${className}`);
    }
    findAllByClassName(className) {
        return this.findAll(`.${className}`);
    }
    /**
     * Returns a wrapper that matches the specified component type with the specified CSS selector.
     *
     * Note: This function returns the specified component's wrapper even if the specified selector points to a different component type.
     *
     * @param {string} selector CSS selector
     * @param {WrapperClass} ComponentClass Component's wrapper class
     * @returns `Wrapper`
     */
    findComponent(selector, ComponentClass) {
        return new ComponentClass(this.find(selector).getElement());
    }
    /**
     * Returns a multi-element wrapper that matches the specified component type with the specified CSS selector.
     * If no CSS selector is specified, returns a multi-element wrapper that matches the specified component type.
     *
     * @param {string} [selector] CSS Selector
     * @returns {MultiElementWrapper}
     */
    findAllComponents(ComponentClass, selector) {
        let componentRootSelector = `.${ComponentClass.rootSelector}`;
        if ('legacyRootSelector' in ComponentClass && ComponentClass.legacyRootSelector) {
            componentRootSelector = `:is(.${ComponentClass.rootSelector}, .${ComponentClass.legacyRootSelector})`;
        }
        const componentCombinedSelector = selector
            ? (0, utils_1.appendSelector)(componentRootSelector, selector)
            : componentRootSelector;
        const rootSelector = getRootSelector(componentCombinedSelector, this.root);
        return new MultiElementWrapper(rootSelector, selector => new ComponentClass(selector));
    }
    toSelector() {
        return this.root;
    }
}
exports.AbstractWrapper = AbstractWrapper;
class ElementWrapper extends AbstractWrapper {
}
exports.ElementWrapper = ElementWrapper;
class ComponentWrapper extends AbstractWrapper {
}
exports.ComponentWrapper = ComponentWrapper;
class MultiElementWrapper extends ElementWrapper {
    constructor(root, elementFactory) {
        super(root);
        this.elementFactory = elementFactory;
    }
    /**
     * Index is one-based because the method uses the :nth-child() CSS pseudo-class.
     */
    get(index) {
        return this.elementFactory(`${this.root}:nth-child(${index})`);
    }
    map(factory) {
        return new MultiElementWrapper(this.root, root => factory(new ElementWrapper(root)));
    }
}
exports.MultiElementWrapper = MultiElementWrapper;
function createWrapper(root = 'body') {
    return new ElementWrapper(root);
}
exports.createWrapper = createWrapper;
