// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useEffect, useRef, useState } from 'react';
import clsx from 'clsx';
import { useMergeRefs } from '@cloudscape-design/component-toolkit/internal';
import InternalIcon from '../../icon/internal.js';
import { getBaseProps } from '../../internal/base-component';
import CheckboxIcon from '../../internal/components/checkbox-icon';
import Option from '../../internal/components/option';
import SelectableItem from '../../internal/components/selectable-item';
import useHiddenDescription from '../../internal/hooks/use-hidden-description';
import Tooltip from '../../tooltip/internal.js';
import styles from './styles.css.js';
const toSelectOptionGroupItem = (props) => {
    var _a;
    return {
        type: 'group',
        index: (_a = props.virtualIndex) !== null && _a !== void 0 ? _a : props.index,
        option: props.option.option,
        disabled: props.disabled,
    };
};
const toSelectOptionItem = (props) => {
    var _a, _b, _c, _d;
    return {
        type: 'item',
        index: (_a = props.virtualIndex) !== null && _a !== void 0 ? _a : props.index,
        option: props.option.option,
        selected: props.selected,
        highlighted: props.highlighted,
        disabled: props.disabled,
        parent: props.parentProps
            ? toSelectOptionGroupItem({
                index: (_b = props.parentProps) === null || _b === void 0 ? void 0 : _b.index,
                virtualIndex: (_c = props.parentProps) === null || _c === void 0 ? void 0 : _c.virtualIndex,
                option: (_d = props.parentProps) === null || _d === void 0 ? void 0 : _d.option,
                disabled: props.disabled,
            })
            : null,
    };
};
const Item = ({ index, virtualIndex, option, highlighted, selected, filteringValue, hasCheckbox, virtualPosition, padBottom, isNextSelected, isPreviousSelected, screenReaderContent, ariaPosinset, ariaSetsize, highlightType, withScrollbar, sticky, renderOption, parentProps, ...restProps }, ref) => {
    const baseProps = getBaseProps(restProps);
    const isParent = option.type === 'parent';
    const isChild = option.type === 'child';
    const wrappedOption = option.option;
    const disabled = option.disabled || wrappedOption.disabled;
    const disabledReason = disabled && wrappedOption.disabledReason ? wrappedOption.disabledReason : '';
    const isDisabledWithReason = !!disabledReason;
    const internalRef = useRef(null);
    const { descriptionEl, descriptionId } = useHiddenDescription(disabledReason);
    const [canShowTooltip, setCanShowTooltip] = useState(true);
    useEffect(() => setCanShowTooltip(true), [highlighted]);
    const getSelectItemProps = (option) => {
        if (option.type === 'parent') {
            return toSelectOptionGroupItem({
                option: option,
                index: index,
                virtualIndex: virtualIndex,
                disabled: !!disabled,
            });
        }
        else {
            return toSelectOptionItem({
                option: option,
                index: index,
                virtualIndex: virtualIndex,
                disabled: !!disabled,
                highlighted: !!highlighted,
                selected: !!selected,
                parentProps: parentProps,
            });
        }
    };
    const renderOptionWrapper = (option) => {
        if (!renderOption) {
            return null;
        }
        return renderOption({ item: getSelectItemProps(option), filterText: filteringValue });
    };
    const renderResult = renderOptionWrapper(option);
    return (React.createElement(SelectableItem, { disableContentStyling: !!renderResult, ariaSelected: Boolean(selected), selected: selected, isNextSelected: isNextSelected, isPreviousSelected: isPreviousSelected, highlighted: highlighted, disabled: option.disabled, isParent: isParent, isChild: isChild, ref: useMergeRefs(ref, internalRef), virtualPosition: virtualPosition, padBottom: padBottom, screenReaderContent: screenReaderContent, ariaPosinset: ariaPosinset, ariaSetsize: ariaSetsize, highlightType: highlightType, ariaDescribedby: isDisabledWithReason ? descriptionId : '', value: option.option.value, withScrollbar: withScrollbar, sticky: sticky, ...baseProps },
        React.createElement("div", { className: clsx(styles.item, !isParent && wrappedOption.labelTag && styles['show-label-tag']) },
            !renderResult && hasCheckbox && !isParent && (React.createElement("div", { className: styles.checkbox },
                React.createElement(CheckboxIcon, { checked: selected || false, disabled: option.disabled }))),
            React.createElement(Option, { customContent: renderResult, option: { ...wrappedOption, disabled }, highlightedOption: highlighted, selectedOption: selected, highlightText: filteringValue, isGroupOption: isParent }),
            !renderResult && !hasCheckbox && !isParent && selected && (React.createElement("div", { className: styles['selected-icon'] },
                React.createElement(InternalIcon, { name: "check" }))),
            !renderResult && isDisabledWithReason && (React.createElement(React.Fragment, null,
                descriptionEl,
                highlighted && canShowTooltip && (React.createElement(Tooltip, { className: styles['disabled-reason-tooltip'], getTrack: () => internalRef.current, content: disabledReason, position: "right", onEscape: () => setCanShowTooltip(false) })))))));
};
export default React.memo(React.forwardRef(Item));
//# sourceMappingURL=item.js.map