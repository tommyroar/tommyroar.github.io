// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useEffect, useRef, useState } from 'react';
import { useMergeRefs } from '@cloudscape-design/component-toolkit/internal';
import { getBaseProps } from '../../internal/base-component';
import CheckboxIcon from '../../internal/components/checkbox-icon';
import Option from '../../internal/components/option';
import SelectableItem from '../../internal/components/selectable-item';
import useHiddenDescription from '../../internal/hooks/use-hidden-description';
import Tooltip from '../../tooltip/internal.js';
import styles from './styles.css.js';
const toMultiselectOptionGroupItem = (props) => {
    var _a, _b;
    return {
        type: 'group',
        index: (_a = props.virtualIndex) !== null && _a !== void 0 ? _a : props.index,
        option: props.option.option,
        indeterminate: (_b = props.indeterminate) !== null && _b !== void 0 ? _b : false,
        selected: props.selected,
        highlighted: props.highlighted,
        disabled: props.disabled,
    };
};
const toMultiselectOptionItem = (props) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return {
        type: 'item',
        index: (_a = props.virtualIndex) !== null && _a !== void 0 ? _a : props.index,
        option: props.option.option,
        selected: props.selected,
        highlighted: props.highlighted,
        disabled: props.disabled,
        parent: props.parentProps
            ? toMultiselectOptionGroupItem({
                index: (_b = props.parentProps) === null || _b === void 0 ? void 0 : _b.index,
                virtualIndex: (_c = props.parentProps) === null || _c === void 0 ? void 0 : _c.virtualIndex,
                option: (_d = props.parentProps) === null || _d === void 0 ? void 0 : _d.option,
                disabled: props.disabled,
                highlighted: (_f = (_e = props.parentProps) === null || _e === void 0 ? void 0 : _e.highlighted) !== null && _f !== void 0 ? _f : false,
                indeterminate: (_h = (_g = props.parentProps) === null || _g === void 0 ? void 0 : _g.indeterminate) !== null && _h !== void 0 ? _h : false,
                selected: (_k = (_j = props.parentProps) === null || _j === void 0 ? void 0 : _j.selected) !== null && _k !== void 0 ? _k : false,
            })
            : null,
    };
};
const MultiSelectItem = ({ index, virtualIndex, option, highlighted, selected, filteringValue, hasCheckbox, virtualPosition, padBottom, isNextSelected, isPreviousSelected, indeterminate, screenReaderContent, ariaPosinset, ariaSetsize, highlightType, withScrollbar, sticky, renderOption, parentProps, ...restProps }, ref) => {
    const baseProps = getBaseProps(restProps);
    const isParent = option.type === 'parent';
    const isChild = option.type === 'child';
    const isSelectAll = option.type === 'select-all';
    const wrappedOption = option.option;
    const disabled = option.disabled || wrappedOption.disabled;
    const disabledReason = disabled && (option.disabledReason || wrappedOption.disabledReason)
        ? option.disabledReason || wrappedOption.disabledReason
        : '';
    const isDisabledWithReason = !!disabledReason;
    const internalRef = useRef(null);
    const className = styles.item;
    const { descriptionId, descriptionEl } = useHiddenDescription(disabledReason);
    const [canShowTooltip, setCanShowTooltip] = useState(true);
    useEffect(() => setCanShowTooltip(true), [highlighted]);
    const getMultiselectItemProps = (option) => {
        if (option.type === 'parent') {
            return toMultiselectOptionGroupItem({
                option: option,
                index: index,
                virtualIndex: virtualIndex,
                disabled: !!disabled,
                highlighted: !!highlighted,
                selected: !!selected,
                indeterminate: indeterminate !== null && indeterminate !== void 0 ? indeterminate : false,
            });
        }
        else if (option.type === 'select-all') {
            return {
                type: 'select-all',
                option: option.option,
                indeterminate: indeterminate !== null && indeterminate !== void 0 ? indeterminate : false,
                selected: !!selected,
                highlighted: !!highlighted,
            };
        }
        else {
            return toMultiselectOptionItem({
                option: option,
                index: index,
                virtualIndex: virtualIndex,
                disabled: !!disabled,
                highlighted: !!highlighted,
                selected: !!selected,
                parentProps: parentProps,
            });
        }
    };
    const renderOptionWrapper = (option) => {
        if (!renderOption) {
            return null;
        }
        return renderOption({ item: getMultiselectItemProps(option), filterText: filteringValue });
    };
    const renderResult = renderOptionWrapper(option);
    return (React.createElement(SelectableItem, { disableContentStyling: !!renderResult, ariaSelected: isParent && indeterminate ? undefined : Boolean(selected), ariaChecked: isParent && indeterminate ? 'mixed' : Boolean(selected), selected: selected, isNextSelected: isNextSelected, isPreviousSelected: isPreviousSelected, highlighted: highlighted, disabled: disabled, isParent: isParent, isChild: isChild, isSelectAll: isSelectAll, highlightType: highlightType, ref: useMergeRefs(ref, internalRef), virtualPosition: virtualPosition, padBottom: padBottom, useInteractiveGroups: true, screenReaderContent: screenReaderContent, ariaPosinset: ariaPosinset, ariaSetsize: ariaSetsize, ariaDescribedby: isDisabledWithReason ? descriptionId : '', value: option.option.value, afterHeader: option.afterHeader, withScrollbar: withScrollbar, sticky: sticky, ...baseProps },
        React.createElement("div", { className: className },
            !renderResult && hasCheckbox && (React.createElement("div", { className: styles.checkbox },
                React.createElement(CheckboxIcon, { checked: selected, indeterminate: (isParent || isSelectAll) && indeterminate, disabled: disabled }))),
            React.createElement(Option, { customContent: renderResult, option: { ...wrappedOption, disabled }, highlightedOption: highlighted, selectedOption: selected, highlightText: filteringValue, isGroupOption: isParent })),
        !renderResult && isDisabledWithReason && (React.createElement(React.Fragment, null,
            descriptionEl,
            highlighted && canShowTooltip && (React.createElement(Tooltip, { className: styles['disabled-reason-tooltip'], getTrack: () => internalRef.current, content: disabledReason, position: "right", onEscape: () => setCanShowTooltip(false) }))))));
};
export default React.memo(React.forwardRef(MultiSelectItem));
//# sourceMappingURL=multiselect-item.js.map