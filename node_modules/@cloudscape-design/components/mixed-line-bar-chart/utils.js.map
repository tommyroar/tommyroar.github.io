{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/mixed-line-bar-chart/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartSeriesMarkerType } from '../internal/components/chart-series-marker';\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps } from './interfaces';\nimport { ScaledBarGroup } from './make-scaled-bar-groups';\n\nexport const chartLegendMap: Record<string, ChartSeriesMarkerType> = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed',\n};\n\n// Starting from the given index, find the first x value in the x domain that has bar data attached to it.\nexport const nextValidDomainIndex = <T>(nextGroupIndex: number, barGroups: ScaledBarGroup<T>[], direction = 1) => {\n  let index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n    index += direction;\n\n    // Loop back to the beginning if necessary\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n  return 0;\n};\n\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\nexport function findNavigableSeries<T extends ChartDataTypes>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const navigableSeries: Array<MixedLineBarChartProps.ChartSeries<T>> = [];\n  let navigableBarSeriesIndex = -1;\n\n  series.forEach(internalSeries => {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return { navigableSeries, navigableBarSeriesIndex };\n}\n\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\nexport const matchesX = <T>(x1: T, x2: T) => {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n  return x1 === x2;\n};\n\nexport type StackedBarValues = Map<string | number, Map<number, number>>;\n\n// Unlike for regular bars, stacked bar series values depend on the predecessors.\n// The function computes all stacked values grouped by X and series index.\nexport function calculateStackedBarValues(\n  dataBySeries: Array<readonly MixedLineBarChartProps.Datum<ChartDataTypes>[]>\n): StackedBarValues {\n  const negativeValues = new Map<string | number, number>();\n  const positiveValues = new Map<string | number, number>();\n  const values = new Map<string | number, Map<number, number>>();\n  for (let seriesIndex = 0; seriesIndex < dataBySeries.length; seriesIndex++) {\n    for (const datum of dataBySeries[seriesIndex]) {\n      const key = getKeyValue(datum.x);\n      if (datum.y < 0) {\n        negativeValues.set(key, (negativeValues.get(key) ?? 0) + datum.y);\n      } else {\n        positiveValues.set(key, (positiveValues.get(key) ?? 0) + datum.y);\n      }\n      const seriesValue = (datum.y < 0 ? negativeValues.get(key) : positiveValues.get(key)) ?? 0;\n      const valuesByIndex = values.get(key) ?? new Map<number, number>();\n      valuesByIndex.set(seriesIndex, seriesValue);\n      values.set(key, valuesByIndex);\n    }\n  }\n  return values;\n}\n\n/** Returns string or number value for ChartDataTypes key */\nexport const getKeyValue = (key: ChartDataTypes) => (key instanceof Date ? key.getTime() : key);\n\nexport function isYThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.YThresholdSeries {\n  return series.type === 'threshold' && 'y' in series;\n}\n\nexport function isXThreshold<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.XThresholdSeries<T> {\n  return series.type === 'threshold' && 'x' in series;\n}\n\nexport function isDataSeries<T>(\n  series: MixedLineBarChartProps.ChartSeries<T>\n): series is MixedLineBarChartProps.DataSeries<T> {\n  return series.type === 'line' || series.type === 'bar';\n}\n"]}