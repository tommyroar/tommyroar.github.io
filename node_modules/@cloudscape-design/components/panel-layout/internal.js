// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useEffect } from 'react';
import clsx from 'clsx';
import { useMergeRefs, useStableCallback } from '@cloudscape-design/component-toolkit/internal';
import { useResize } from '../app-layout/visual-refresh-toolbar/drawer/use-resize';
import { getBaseProps } from '../internal/base-component';
import PanelResizeHandle from '../internal/components/panel-resize-handle';
import { fireNonCancelableEvent } from '../internal/events';
import { useControllable } from '../internal/hooks/use-controllable';
import useContainerWidth from '../internal/utils/use-container-width';
import styles from './styles.css.js';
import testStyles from './test-classes/styles.css.js';
const DEFAULT_PANEL_SIZE = 200;
const InternalPanelLayout = React.forwardRef(({ panelPosition, panelContent, mainContent, defaultPanelSize, panelSize: controlledPanelSize, resizable, onPanelResize, onLayoutChange, minPanelSize, maxPanelSize, i18nStrings, display, panelFocusable, mainFocusable, __internalRootRef, ...props }, ref) => {
    const baseProps = getBaseProps(props);
    const resizeHandleRef = React.useRef(null);
    const panelRef = React.useRef(null);
    const [containerWidth, rootRef] = useContainerWidth();
    React.useImperativeHandle(ref, () => ({
        focusResizeHandle() {
            var _a;
            (_a = resizeHandleRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        },
    }), []);
    const [panelSize = DEFAULT_PANEL_SIZE, setPanelSize] = useControllable(controlledPanelSize, onPanelResize, defaultPanelSize !== null && defaultPanelSize !== void 0 ? defaultPanelSize : minPanelSize, {
        componentName: 'PanelLayout',
        controlledProp: 'panelSize',
        changeHandler: 'onPanelResize',
    });
    const actualMaxSize = Math.min(maxPanelSize !== null && maxPanelSize !== void 0 ? maxPanelSize : containerWidth, containerWidth);
    const actualMinSize = minPanelSize !== null && minPanelSize !== void 0 ? minPanelSize : 0;
    const actualPanelSize = Math.max(Math.min(panelSize, actualMaxSize), actualMinSize);
    const stableLayoutChangeEvent = useStableCallback((details) => fireNonCancelableEvent(onLayoutChange, details));
    useEffect(() => {
        stableLayoutChangeEvent({ totalSize: containerWidth, panelSize: actualPanelSize });
    }, [containerWidth, actualPanelSize, stableLayoutChangeEvent]);
    const resizeHandlePosition = panelPosition === 'side-end' ? 'side' : panelPosition;
    const resizeProps = useResize({
        currentWidth: actualPanelSize,
        minWidth: actualMinSize,
        maxWidth: actualMaxSize,
        panelRef: panelRef,
        handleRef: resizeHandleRef,
        position: resizeHandlePosition,
        onResize: size => {
            setPanelSize(size);
            fireNonCancelableEvent(onPanelResize, { totalSize: containerWidth, panelSize: size });
        },
    });
    const mergedRef = useMergeRefs(rootRef, __internalRootRef, ref);
    const wrappedPanelContent = (React.createElement("div", { className: clsx(styles['panel-content'], display !== 'main-only' && testStyles.panel), tabIndex: panelFocusable && 0, role: panelFocusable && 'region', "aria-label": panelFocusable === null || panelFocusable === void 0 ? void 0 : panelFocusable.ariaLabel, "aria-labelledby": panelFocusable === null || panelFocusable === void 0 ? void 0 : panelFocusable.ariaLabelledby }, panelContent));
    const wrappedMainContent = (React.createElement("div", { className: clsx(styles.content, display !== 'panel-only' && testStyles.content), tabIndex: mainFocusable && 0, role: mainFocusable && 'region', "aria-label": mainFocusable === null || mainFocusable === void 0 ? void 0 : mainFocusable.ariaLabel, "aria-labelledby": mainFocusable === null || mainFocusable === void 0 ? void 0 : mainFocusable.ariaLabelledby }, mainContent));
    const handle = (React.createElement("div", { className: styles.handle },
        React.createElement(PanelResizeHandle, { ref: resizeHandleRef, className: testStyles['resize-handle'], position: resizeHandlePosition, ariaLabel: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.resizeHandleAriaLabel, tooltipText: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.resizeHandleTooltipText, ariaValuenow: resizeProps.relativeSize, onKeyDown: resizeProps.onKeyDown, onDirectionClick: resizeProps.onDirectionClick, onPointerDown: resizeProps.onPointerDown })));
    return (React.createElement("div", { ...baseProps, ref: mergedRef, className: clsx(baseProps.className, styles.root, testStyles.root, styles[`display-${display}`]) },
        panelPosition === 'side-end' && wrappedMainContent,
        React.createElement("div", { className: clsx(styles.panel), ref: panelRef, style: display === 'all' ? { inlineSize: `${actualPanelSize}px` } : undefined },
            panelPosition === 'side-start' && wrappedPanelContent,
            resizable && display === 'all' && handle,
            panelPosition === 'side-end' && wrappedPanelContent),
        panelPosition === 'side-start' && wrappedMainContent));
});
export default InternalPanelLayout;
//# sourceMappingURL=internal.js.map