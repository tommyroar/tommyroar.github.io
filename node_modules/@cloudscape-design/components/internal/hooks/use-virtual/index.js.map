{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/internal/hooks/use-virtual/index.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AACtC,OAAc,EAAE,SAAS,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,OAAO,CAAC;AAE1D,OAAO,EAAE,UAAU,IAAI,iBAAiB,EAAe,MAAM,4BAA4B,CAAC;AAC1F,OAAO,oBAAoB,MAAM,0BAA0B,CAAC;AAE5D,8EAA8E;AAC9E,sEAAsE;AACtE,sFAAsF;AACtF,yFAAyF;AACzF,MAAM,eAAe,GAAG,EAAE,GAAG,CAAC,CAAC;AAe/B;;;;;;;;;;;GAWG;AACH,MAAM,UAAU,UAAU,CAAsB,EAC9C,KAAK,EACL,SAAS,EACT,YAAY,EACZ,eAAe,GACO;;IACtB,MAAM,cAAc,GAAG,iBAAiB,CAAC;QACvC,IAAI,EAAE,KAAK,CAAC,MAAM;QAClB,SAAS;QACT,YAAY;QACZ,QAAQ,EAAE,CAAC;QACX,cAAc,EAAE,eAAe,CAAC,CAAC,CAAC,oBAAoB,CAAC,CAAC,CAAC,SAAS;KACnE,CAAC,CAAC;IAEH,oEAAoE;IACpE,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,OAAO,EAAgB,CAAC,CAAC;IAE1D,yEAAyE;IACzE,MAAM,UAAU,GAAG,cAAc,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,KAAK,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;IACtF,SAAS,CAAC,GAAG,EAAE;QACb,aAAa,CAAC,OAAO,GAAG,IAAI,OAAO,EAAE,CAAC;IACxC,CAAC,EAAE,CAAC,UAAU,EAAE,KAAK,EAAE,YAAY,CAAC,CAAC,CAAC;IAEtC,MAAM,YAAY,GAAG,OAAO,CAC1B,GAAG,EAAE,CACH,cAAc,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC;QAC9C,GAAG,WAAW;QACd,KAAK,EAAE,WAAW,CAAC,KAAK;QACxB,UAAU,EAAE,CAAC,IAAwB,EAAE,EAAE;;YACvC,MAAM,YAAY,GAAG,MAAA,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,mCAAI,CAAC,CAAC;YAC9E,IAAI,YAAY,GAAG,eAAe,EAAE,CAAC;gBACnC,WAAW,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBAC7B,aAAa,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE,YAAY,GAAG,CAAC,CAAC,CAAC;YACxE,CAAC;QACH,CAAC;KACF,CAAC,CAAC,EACL,CAAC,KAAK,EAAE,cAAc,CAAC,YAAY,CAAC,CACrC,CAAC;IAEF,0EAA0E;IAC1E,MAAM,aAAa,GAAG,MAAA,MAAA,YAAY,CAAC,CAAC,CAAC,0CAAE,IAAI,mCAAI,CAAC,CAAC;IACjD,MAAM,iBAAiB,GAAG,eAAe,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,GAAG,aAAa,CAAC,CAAC,CAAC,cAAc,CAAC,SAAS,CAAC;IAEhH,OAAO;QACL,YAAY;QACZ,SAAS,EAAE,iBAAiB;QAC5B,aAAa,EAAE,cAAc,CAAC,aAAa;KAC5C,CAAC;AACJ,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useMemo, useRef } from 'react';\n\nimport { useVirtual as useVirtualDefault, VirtualItem } from '../../vendor/react-virtual';\nimport stickyRangeExtractor from './sticky-range-extractor';\n\n// Maximum allowed synchronous (nested) item mounts before forcing a bail-out.\n// Mirrors Reactâ€™s internal safeguard for nested updates: React throws\n// \"Maximum update depth exceeded\" once >50 sync updates occur within a single commit.\n// See: https://github.com/facebook/react/commit/d8c90fa48d3addefe4b805ec56a3c65e4ee39127\nconst MAX_ITEM_MOUNTS = 50 - 1;\n\ninterface UseVirtualProps<Item> {\n  items: readonly Item[];\n  parentRef: React.RefObject<HTMLElement>;\n  estimateSize: () => number;\n  firstItemSticky?: boolean;\n}\n\ninterface RowVirtualizer {\n  virtualItems: VirtualItem[];\n  totalSize: number;\n  scrollToIndex: (index: number) => void;\n}\n\n/**\n * The useVirtual from react-virtual@2 might produce an infinite update loop caused by setting\n * measured item sizes in the render cycle (as part of the measureRef assignment):\n *      The sum of all measured item sizes is returned as totalSize which is then set on the list container.\n *      Enforcing new container height might result in an items size change e.g. when the content wraps.\n *\n * The infinite update cycle causes React \"Maximum update depth exceeded\" error and can be additionally confirmed\n * by logging the totalSize which should then bounce between two values.\n *\n * The number of item refs assignments is limited to MAX_ITEM_MOUNTS unless items or indices change.\n * That is based on the assumption the item height stays constant after its first render.\n */\nexport function useVirtual<Item extends object>({\n  items,\n  parentRef,\n  estimateSize,\n  firstItemSticky,\n}: UseVirtualProps<Item>): RowVirtualizer {\n  const rowVirtualizer = useVirtualDefault({\n    size: items.length,\n    parentRef,\n    estimateSize,\n    overscan: 5,\n    rangeExtractor: firstItemSticky ? stickyRangeExtractor : undefined,\n  });\n\n  // Cache virtual item mounts to limit the amount of mounts per item.\n  const measuresCache = useRef(new WeakMap<Item, number>());\n\n  // Clear mounts cache every time indices, items, or size estimate change.\n  const indicesKey = rowVirtualizer.virtualItems.map(item => `${item.index}`).join(':');\n  useEffect(() => {\n    measuresCache.current = new WeakMap();\n  }, [indicesKey, items, estimateSize]);\n\n  const virtualItems = useMemo(\n    () =>\n      rowVirtualizer.virtualItems.map(virtualItem => ({\n        ...virtualItem,\n        start: virtualItem.start,\n        measureRef: (node: null | HTMLElement) => {\n          const mountedCount = measuresCache.current.get(items[virtualItem.index]) ?? 0;\n          if (mountedCount < MAX_ITEM_MOUNTS) {\n            virtualItem.measureRef(node);\n            measuresCache.current.set(items[virtualItem.index], mountedCount + 1);\n          }\n        },\n      })),\n    [items, rowVirtualizer.virtualItems]\n  );\n\n  // If first item is sticky, substract that item's size from the total size\n  const firstItemSize = virtualItems[0]?.size ?? 0;\n  const adjustedTotalSize = firstItemSticky ? rowVirtualizer.totalSize - firstItemSize : rowVirtualizer.totalSize;\n\n  return {\n    virtualItems,\n    totalSize: adjustedTotalSize,\n    scrollToIndex: rowVirtualizer.scrollToIndex,\n  };\n}\n"]}