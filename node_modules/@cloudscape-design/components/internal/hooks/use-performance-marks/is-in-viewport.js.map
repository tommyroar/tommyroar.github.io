{"version":3,"file":"is-in-viewport.js","sourceRoot":"","sources":["../../../../../src/internal/hooks/use-performance-marks/is-in-viewport.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAGtC,MAAM,GAAG,GAAG,IAAI,OAAO,EAAqB,CAAC;AAE7C,MAAM,oBAAoB,GAAG,GAAG,CAAC;AAEjC;;;;GAIG;AACH,MAAM,UAAU,YAAY,CAAC,OAAgB,EAAE,QAAkB;IAC/D,IAAI,OAAO,GAAG,CAAC,KAAc,EAAE,EAAE;QAC/B,OAAO,GAAG,GAAG,EAAE,GAAE,CAAC,CAAC,CAAC,6BAA6B;QACjD,QAAQ,CAAC,KAAK,CAAC,CAAC;IAClB,CAAC,CAAC;IAEF,GAAG,CAAC,GAAG,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC;IACpD,QAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;IAE1B;;;;;SAKE;IACF,MAAM,aAAa,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,oBAAoB,CAAC,CAAC;IAE7E,UAAU;IACV,OAAO,GAAG,EAAE;QACV,YAAY,CAAC,aAAa,CAAC,CAAC;QAC5B,GAAG,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;QACpB,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAC9B,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,0BAA0B,CAAC,QAAsC;IACxE,IAAI,OAAO,oBAAoB,KAAK,WAAW,EAAE,CAAC;QAChD,OAAO;YACL,OAAO,EAAE,GAAG,EAAE,GAAE,CAAC;YACjB,SAAS,EAAE,GAAG,EAAE,GAAE,CAAC;SACpB,CAAC;IACJ,CAAC;IACD,OAAO,IAAI,oBAAoB,CAAC,QAAQ,CAAC,CAAC;AAC5C,CAAC;AAED,MAAM,QAAQ,GAAG,0BAA0B,CAAC,SAAS,oBAAoB,CAAC,OAAO;;IAC/E,KAAK,MAAM,KAAK,IAAI,OAAO,EAAE,CAAC;QAC5B,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,+DAA+D;QACjG,MAAA,GAAG,CAAC,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,0CAAG,KAAK,CAAC,cAAc,CAAC,CAAC;QAC9C,GAAG,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAC3B,CAAC;AACH,CAAC,CAAC,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\ntype Callback = (inViewport: boolean) => void;\nconst map = new WeakMap<Element, Callback>();\n\nconst MANUAL_TRIGGER_DELAY = 150;\n\n/**\n * This function determines whether an element is in the viewport. The callback\n * is batched with other elements that also use this function, in order to improve\n * performance.\n */\nexport function isInViewport(element: Element, callback: Callback) {\n  let resolve = (value: boolean) => {\n    resolve = () => {}; // Prevent multiple execution\n    callback(value);\n  };\n\n  map.set(element, inViewport => resolve(inViewport));\n  observer.observe(element);\n\n  /*\n\t If the IntersectionObserver does not fire in reasonable time (for example\n\t in a background page in Chrome), we need to call the callback manually.\n  \n\t See https://issues.chromium.org/issues/41383759\n\t */\n  const timeoutHandle = setTimeout(() => resolve(false), MANUAL_TRIGGER_DELAY);\n\n  // Cleanup\n  return () => {\n    clearTimeout(timeoutHandle);\n    map.delete(element);\n    observer.unobserve(element);\n  };\n}\n\nfunction createIntersectionObserver(callback: IntersectionObserverCallback) {\n  if (typeof IntersectionObserver === 'undefined') {\n    return {\n      observe: () => {},\n      unobserve: () => {},\n    };\n  }\n  return new IntersectionObserver(callback);\n}\n\nconst observer = createIntersectionObserver(function isInViewportObserver(entries) {\n  for (const entry of entries) {\n    observer.unobserve(entry.target); // We only want the first run of the observer for each element.\n    map.get(entry.target)?.(entry.isIntersecting);\n    map.delete(entry.target);\n  }\n});\n"]}