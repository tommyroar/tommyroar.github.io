{"version":3,"file":"highlight-match.js","sourceRoot":"","sources":["../../../../../src/internal/components/option/highlight-match.tsx"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AACtC,OAAO,KAAK,MAAM,OAAO,CAAC;AAE1B,OAAO,MAAM,MAAM,iBAAiB,CAAC;AAErC,MAAM,gBAAgB,GAAG,CAAC,GAAW,EAAE,aAAqB,EAAE,EAAE;IAC9D,uEAAuE;IACvE,qEAAqE;IACrE,IAAI,aAAa,CAAC,MAAM,GAAG,KAAM,EAAE,CAAC;QAClC,OAAO,EAAE,SAAS,EAAE,CAAC,GAAG,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC;IAC7C,CAAC;IAED,yCAAyC;IACzC,MAAM,gBAAgB,GAAG,aAAa,CAAC,OAAO,CAAC,uBAAuB,EAAE,MAAM,CAAC,CAAC;IAChF,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;IAClD,MAAM,SAAS,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACpC,MAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAElC,OAAO,EAAE,SAAS,EAAE,OAAO,EAAE,CAAC;AAChC,CAAC,CAAC;AAQF,SAAS,SAAS,CAAC,EAAE,GAAG,EAAE,QAAQ,EAAuB;IACvD,OAAO,CACL,8BAAM,GAAG,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,CAAC,2BAA2B,CAAC,IAChE,GAAG,CACC,CACR,CAAC;AACJ,CAAC;AAED,MAAM,CAAC,OAAO,UAAU,cAAc,CAAC,EAAE,GAAG,EAAE,aAAa,EAAE,QAAQ,EAAuB;IAC1F,IAAI,CAAC,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QAC3B,OAAO,8BAAM,GAAG,EAAE,QAAQ,IAAG,GAAG,CAAQ,CAAC;IAC3C,CAAC;IAED,IAAI,GAAG,KAAK,aAAa,EAAE,CAAC;QAC1B,OAAO,oBAAC,SAAS,IAAC,QAAQ,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,GAAI,CAAC;IACrD,CAAC;IAED,MAAM,EAAE,SAAS,EAAE,OAAO,EAAE,GAAG,gBAAgB,CAAC,GAAG,EAAE,aAAa,CAAC,CAAC;IAEpE,MAAM,WAAW,GAA6B,EAAE,CAAC;IAEjD,SAAS,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,GAAG,EAAE,EAAE;QACjC,WAAW,CAAC,IAAI,CAAC,8BAAM,GAAG,EAAE,WAAW,GAAG,EAAE,IAAG,OAAO,CAAQ,CAAC,CAAC;QAEhE,IAAI,OAAO,IAAI,GAAG,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;YACpC,WAAW,CAAC,IAAI,CAAC,oBAAC,SAAS,IAAC,GAAG,EAAE,SAAS,GAAG,EAAE,EAAE,GAAG,EAAE,OAAO,CAAC,GAAG,CAAC,GAAI,CAAC,CAAC;QAC1E,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,8BAAM,GAAG,EAAE,QAAQ,IAAG,WAAW,CAAQ,CAAC;AACnD,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React from 'react';\n\nimport styles from './styles.css.js';\n\nconst splitOnFiltering = (str: string, highlightText: string) => {\n  // We match by creating a regex using user-provided strings, so we skip\n  // highlighting if the generated regex would be too memory intensive.\n  if (highlightText.length > 10_000) {\n    return { noMatches: [str], matches: null };\n  }\n\n  // Filtering needs to be case insensitive\n  const filteringPattern = highlightText.replace(/[-[\\]/{}()*+?.\\\\^$|]/g, '\\\\$&');\n  const regexp = new RegExp(filteringPattern, 'gi');\n  const noMatches = str.split(regexp);\n  const matches = str.match(regexp);\n\n  return { noMatches, matches };\n};\n\ninterface HighlightMatchProps {\n  str?: string;\n  highlightText?: string;\n  labelRef?: React.RefObject<HTMLElement>;\n}\n\nfunction Highlight({ str, labelRef }: HighlightMatchProps) {\n  return (\n    <mark ref={labelRef} className={styles['filtering-match-highlight']}>\n      {str}\n    </mark>\n  );\n}\n\nexport default function HighlightMatch({ str, highlightText, labelRef }: HighlightMatchProps) {\n  if (!str || !highlightText) {\n    return <span ref={labelRef}>{str}</span>;\n  }\n\n  if (str === highlightText) {\n    return <Highlight labelRef={labelRef} str={str} />;\n  }\n\n  const { noMatches, matches } = splitOnFiltering(str, highlightText);\n\n  const highlighted: (string | JSX.Element)[] = [];\n\n  noMatches.forEach((noMatch, idx) => {\n    highlighted.push(<span key={`noMatch-${idx}`}>{noMatch}</span>);\n\n    if (matches && idx < matches.length) {\n      highlighted.push(<Highlight key={`match-${idx}`} str={matches[idx]} />);\n    }\n  });\n\n  return <span ref={labelRef}>{highlighted}</span>;\n}\n"]}