{"version":3,"file":"provider.js","sourceRoot":"","sources":["../../../src/i18n/provider.tsx"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useContext } from 'react';\nimport { MessageFormatElement } from '@formatjs/icu-messageformat-parser';\nimport IntlMessageFormat from 'intl-messageformat';\n\nimport { warnOnce } from '@cloudscape-design/component-toolkit/internal';\n\nimport useBaseComponent from '../internal/hooks/use-base-component';\nimport { applyDisplayName } from '../internal/utils/apply-display-name';\nimport { CustomHandler, FormatFunction, InternalI18nContext } from './context';\nimport { getMatchableLocales } from './get-matchable-locales';\n\nexport interface I18nProviderProps {\n  messages: ReadonlyArray<I18nProviderProps.Messages>;\n  locale?: string;\n  children: React.ReactNode;\n}\n\nexport namespace I18nProviderProps {\n  export interface Messages {\n    [namespace: string]: {\n      [locale: string]: {\n        [component: string]: {\n          [key: string]: string | MessageFormatElement[];\n        };\n      };\n    };\n  }\n}\n\n/**\n * Context to send parent messages down to child I18nProviders. This isn't\n * included in the InternalI18nContext to avoid components from depending on\n * MessageFormatElement types.\n */\nconst I18nMessagesContext = React.createContext<I18nProviderProps.Messages>({});\n\nexport function I18nProvider({ messages: messagesArray, locale: providedLocale, children }: I18nProviderProps) {\n  useBaseComponent('I18nProvider');\n\n  if (typeof document === 'undefined' && !providedLocale) {\n    warnOnce(\n      'I18nProvider',\n      'An explicit locale was not provided during server rendering. This can lead to a hydration mismatch on the client.'\n    );\n  }\n\n  // The provider accepts an array of configs. We merge parent messages and\n  // flatten the tree early on so that accesses by key are simpler and faster.\n  const parentMessages = useContext(I18nMessagesContext);\n  const messages = mergeMessages([parentMessages, ...messagesArray]);\n\n  let locale: string;\n  if (providedLocale) {\n    // If a locale is explicitly provided, use the string directly.\n    // Locales have a recommended case, but are matched case-insensitively,\n    // so we lowercase it internally.\n    locale = providedLocale.toLowerCase();\n  } else if (typeof document !== 'undefined' && document.documentElement.lang) {\n    // Otherwise, use the value provided in the HTML tag.\n    locale = document.documentElement.lang.toLowerCase();\n  } else {\n    // Lastly, fall back to English.\n    locale = 'en';\n  }\n\n  // Create a per-render cache of messages and IntlMessageFormat instances.\n  // Not memoizing it allows us to reset the cache when the component rerenders\n  // with potentially different locale or messages. We expect this component to\n  // be placed above AppLayout and therefore rerender very infrequently.\n  const localeFormatterCache = new Map<string, IntlMessageFormat>();\n\n  const format: FormatFunction = <ReturnValue, FormatFnArgs extends Record<string, string | number>>(\n    namespace: string,\n    component: string,\n    key: string,\n    provided: ReturnValue,\n    customHandler?: CustomHandler<ReturnValue, FormatFnArgs>\n  ): ReturnValue => {\n    // A general rule in this library is that undefined is basically\n    // treated as \"not provided\". So even if a user explicitly provides an\n    // undefined value, it will default to i18n provider values.\n    if (provided !== undefined) {\n      return provided;\n    }\n\n    const cacheKey = `${namespace}.${component}.${key}`;\n    let intlMessageFormat: IntlMessageFormat;\n\n    const cachedFormatter = localeFormatterCache.get(cacheKey);\n    if (cachedFormatter) {\n      // If an IntlMessageFormat instance was cached for this locale, just use that.\n      intlMessageFormat = cachedFormatter;\n    } else {\n      // Widen the locale string (e.g. en-GB -> en) until we find a locale\n      // that contains the message we need.\n      let message: string | MessageFormatElement[] | undefined;\n      const matchableLocales = getMatchableLocales(locale);\n      for (const matchableLocale of matchableLocales) {\n        message = messages?.[namespace]?.[matchableLocale]?.[component]?.[key];\n        if (message !== undefined) {\n          break;\n        }\n      }\n\n      // If a message wasn't found, exit early.\n      if (message === undefined) {\n        return provided;\n      }\n\n      // Lazily create an IntlMessageFormat object for this key.\n      intlMessageFormat = new IntlMessageFormat(message, locale);\n      localeFormatterCache.set(cacheKey, intlMessageFormat);\n    }\n\n    if (customHandler) {\n      return customHandler(args => intlMessageFormat.format(args) as string);\n    }\n    // Assuming `T extends string` since a customHandler wasn't provided.\n    return intlMessageFormat.format() as ReturnValue;\n  };\n\n  return (\n    <InternalI18nContext.Provider value={{ locale, format }}>\n      <I18nMessagesContext.Provider value={messages}>{children}</I18nMessagesContext.Provider>\n    </InternalI18nContext.Provider>\n  );\n}\n\napplyDisplayName(I18nProvider, 'I18nProvider');\n\nfunction mergeMessages(sources: ReadonlyArray<I18nProviderProps.Messages>): I18nProviderProps.Messages {\n  const result: I18nProviderProps.Messages = {};\n  for (const messages of sources) {\n    for (const namespace in messages) {\n      if (!(namespace in result)) {\n        result[namespace] = {};\n      }\n      for (const casedLocale in messages[namespace]) {\n        const locale = casedLocale.toLowerCase();\n        if (!(locale in result[namespace])) {\n          result[namespace][locale] = {};\n        }\n        for (const component in messages[namespace][casedLocale]) {\n          if (!(component in result[namespace][locale])) {\n            result[namespace][locale][component] = {};\n          }\n          for (const key in messages[namespace][casedLocale][component]) {\n            result[namespace][locale][component][key] = messages[namespace][casedLocale][component][key];\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n"]}